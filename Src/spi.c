/**
 * @file    spi.c
 * @brief   SPI1 initialization and MSP (GPIO/IRQ) setup for STM32 (HAL).
 *
 * Notes:
 *  - This file is written in a CubeMX-like style but kept explicit and readable.
 *  - The current configuration intentionally disables DMA usage for SPI1 by
 *    clearing hspi1.hdmatx/hdmarx after HAL_SPI_Init().
 *  - If you want DMA, you typically:
 *      1) Enable/link DMA handles via __HAL_LINKDMA()
 *      2) Ensure MX_DMA_Init() enables DMA clocks + NVIC for the right streams
 *      3) Use HAL_SPI_Transmit_DMA / Receive_DMA / TransmitReceive_DMA
 */

#include "spi.h"
#include "dma.h"

SPI_HandleTypeDef hspi1;

/* DMA handles are usually generated by CubeMX (dma.c / stm32xx_hal_msp.c).
 * They are declared extern here so this module can link them to SPI if desired.
 */
extern DMA_HandleTypeDef hdma_spi1_tx;
extern DMA_HandleTypeDef hdma_spi1_rx;

/**
 * @brief Initialize SPI1 as master, 8-bit, mode 0, software NSS.
 *
 * Current behavior:
 *  - Initializes SPI via HAL_SPI_Init()
 *  - Then explicitly disables DMA bindings (Option A) to force polling/blocking
 *    operation (useful if you do simple TFT writes via HAL_SPI_Transmit()).
 *
 * If you want DMA, remove/adjust the "Option A" section and enable __HAL_LINKDMA
 * in HAL_SPI_MspInit().
 */
void MX_SPI1_Init(void)
{
  hspi1.Instance = SPI1;

  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;

  /* SPI mode 0: CPOL=0, CPHA=0 */
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;

  /* NSS managed by software */
  hspi1.Init.NSS = SPI_NSS_SOFT;

  /* Adjust prescaler as needed for your peripheral and wiring quality */
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;

  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;

  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }

  /* --------------------------------------------------------------------------
   * Option A: Force SPI to run without DMA
   * --------------------------------------------------------------------------
   * This is useful for simple blocking transfers (HAL_SPI_Transmit) and avoids
   * surprises if DMA is configured but not fully set up (streams/IRQs).
   *
   * If you want DMA transfers, remove this and link DMA in MSP init.
   */
  hspi1.hdmatx = NULL;
  hspi1.hdmarx = NULL;
}

/**
 * @brief Low-level hardware init for SPI (called by HAL_SPI_Init()).
 *
 * Responsibilities:
 *  - Enable peripheral and GPIO clocks
 *  - Configure SPI SCK/MISO/MOSI pins as alternate function
 *  - Optionally link DMA handles
 *  - Configure interrupts (SPI + DMA streams if used)
 */
void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  if (spiHandle->Instance == SPI1)
  {
    /* --- Clocks ----------------------------------------------------------- */
    __HAL_RCC_SPI1_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    /* DMA clocks are typically enabled in MX_DMA_Init() */

    /* --- GPIO: SPI1 -------------------------------------------------------
     * Example mapping (as in your code):
     *   PA5 -> SPI1_SCK
     *   PA6 -> SPI1_MISO
     *   PB5 -> SPI1_MOSI
     */
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;

    /* SCK + MISO on GPIOA */
    GPIO_InitStruct.Pin = GPIO_PIN_5 | GPIO_PIN_6;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* MOSI on GPIOB */
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* --- DMA linking (optional) -------------------------------------------
     * If you want to use HAL_SPI_*_DMA calls, you MUST link DMA handles here.
     * CubeMX usually generates the hdma_spi1_tx/rx handles and stream config.
     *
     * IMPORTANT:
     *  - Ensure MX_DMA_Init() sets up the correct DMA streams and NVIC.
     *  - Only enable the lines below if the DMA handles are correctly configured.
     */
    //__HAL_LINKDMA(spiHandle, hdmatx, hdma_spi1_tx);
    //__HAL_LINKDMA(spiHandle, hdmarx, hdma_spi1_rx);

    /* --- Interrupts -------------------------------------------------------
     * SPI IRQ is optional unless you rely on SPI error callbacks or IRQ mode.
     * DMA IRQs depend on which stream/channel CubeMX assigned.
     *
     * For DMA, CubeMX will generate something like:
     *   HAL_NVIC_SetPriority(DMAx_Streamy_IRQn, ...);
     *   HAL_NVIC_EnableIRQ(DMAx_Streamy_IRQn);
     *
     * Do NOT copy IRQ names blindly between projects/MCUs.
     */
    HAL_NVIC_SetPriority(SPI1_IRQn, 6, 0);
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
  }
}

/**
 * @brief Low-level hardware deinit for SPI.
 *
 * This reverses what HAL_SPI_MspInit() configured:
 *  - Disable SPI peripheral clock
 *  - Deinit GPIOs used by SPI
 *  - Disable IRQ (and optionally DMA IRQs if you enabled them)
 */
void HAL_SPI_MspDeInit(SPI_HandleTypeDef* spiHandle)
{
  if (spiHandle->Instance == SPI1)
  {
    __HAL_RCC_SPI1_CLK_DISABLE();

    /* Deinit SPI pins */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_5 | GPIO_PIN_6);
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_5);

    /* If DMA was linked/enabled, you can deinit DMA here or in dma.c */
    /* HAL_DMA_DeInit(spiHandle->hdmatx); */
    /* HAL_DMA_DeInit(spiHandle->hdmarx); */

    HAL_NVIC_DisableIRQ(SPI1_IRQn);
  }
}
